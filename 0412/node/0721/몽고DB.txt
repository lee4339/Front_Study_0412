SQL(관계형 데이터베이스)에는 핵심적인 두 가지 특징이 있다.
-데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다.
-데이터는 관계를 통해 여러 테이블에 분산된다.

NoSQL (비관계형 DB)
-스키마도 없고, 관계도 없음

SQL 장점
-명확하게 정의된 스키마, 데이터 무결성 보장
-관계는 각 데이터를 중복없이 한번만 저장

SQL 단점
-덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
-관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
-대체로 수직적 확장만 가능함

NoSQL 장점
-스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
-데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
-수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능

NoSQL 단점
-유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
-데이터 중복을 계속 업데이트 해야 함
-데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)

[MongoDB 문법] no sql

데이터베이스 확인
show dbs;

데이터베이스 생성 및 선택
use 데이터베이스명;
use frontenddb;
* 데이터베이스가 없으면 생성, 있으면 선택합니다.
* 데이터베이스의 자료가 없을 경우 show dbs에서 나타나지 않습니다.

컬렉션 생성
db.createCollection('컬렉션명');
db.createCollection('testCollection');
결과{"ok":1}


컬렉션 확인
show collections;

컬렉션 삭제
db.컬렉션명.drop();
db.testCollection.drop();
결과 true

연습용 컬렉션 만들기
db.createCollection("member");

document 추가
db.컬렉션명.insert(객체);
db.member.insert({'userid':'apple','userpw':'1111'});
db.member.insert({'userid':'banana','userpw':'2222','username':'반하나'});
db.member.insert({"userid":"orange","userpw":"3333","gender":"남자"});
db.member.insert({"userid":"melon","userpw":"4444","gender":"남자", "username":"이메론"});
db.member.insert({"userid":"cherry","userpw":"5555", "username":"채리","gender":"여자","point":2000});
db.member.insert({"userid":"avocado","userpw":"6666", "username":"안카도","gender":"남자","point":1500});
db.member.insert({"userid":"berry","userpw":"7777", "username":"배애리","gender":"여자","point":1800});
db.member.insert({"userid":"coconut","userpw":"8888", "username":"고코넛","gender":"남자","point":1700});

document 확인
db.컬렉션명.find();
db.컬렉션명.find().pretty();
db.컬렉션명.find(객체).pretty();
db.member.find();
db.member.find().pretty();
db.member.find({"userid":"apple"}).pretty();




/MongoDB 정리/
dbs -> Collection -> 객체

1. cmd -> Mongo
2. 데이터베이스 확인 - show dbs
3. 해당되는 데이터베이스 접속 - use 데이터베이스명(use frontenddb)  => use는 db 생성, 선택 (데이터베이스명을 명확히 입력해야함)
4. 컬렉션 생성 - db.createCollection('컬렉션명');
5. 컬렉션 확인 - show collections;
6. 컬렉션 삭제 - db.컬렉션명.drop();
7. document 추가 - db.컬렉션명.insert(객체);
8. document 확인 - db.컬렉션명.find();
                 - db.컬렉션명.find().pretty();  => JSON 파일형식으로 깔끔하게
                 -> 특정 document 선택할때 ->  db.컬렉션명.find(객체).pretty();

* _id는 각 document의 유일한 키로 쓰이는 값입니다.
-> document를 저장하고 확인

document 비교연산 -> 값이 크다 작다의 의미가 아니라 하나의 변수값을 선언하는 것
$eq : 주어진 값과 일치하는 값을 찾습니다.
$gt : 주어진 값보다 큰 값을 찾습니다.
$gte : 주어진 값보다 크거나 같은 값을 찾습니다.
$lt : 주어진 값보다 작은 값을 찾습니다.
$lte : 주어진 값보다 작거나 같은 값을 찾습니다.
$ne : 주어진 값과 일치하지 않는 값을 찾습니다.
$in : 주어진 배열 안에 속하는 값을 찾습니다.
$nin : 주어진 배열 안에 속하지 않는 값을 찾습니다.


문제.
포인트가 1700점 이상인 멤버를 검색합니다.
  db.member.find({point:{$gte:1700}}).pretty();


document 논리연산
$or : 주어진 조건 중 하나라도 true일 때 true인 결과를 찾습니다.
$and : 주어진 모든 조건이 true일 때 true인 결과를 찾습니다.
$not : 주어진 조건이 false일 때 true, true일 때 false인 결과를 찾습니다.

문제.
아이디가 "melon"이고 이름이 "이메론"인 멤버를 검색합니다.
db.member.find({$and:[{'userid':'melon'},{'username':'이메론'}]}).pretty();

->조건이 2가지 이상이면 배열되므로 $and:[]로 표시
->객체는 무조건{}


실습.
1. 이름이 "안카도"인 멤버를 검색합니다.
  db.member.find({'username':'안카도'}).pretty();

2. 포인트가 1800보다 작거나 같은 멤버를 검색합니다.
  db.member.find({point:{$lte:1800}}).pretty();

3. 아이디가 "apple" 이거나 "banana"인 멤버를 검색합니다.
  db.member.find({$or:[{'userid':'apple'}, {'userid' : 'banana'}]}).pretty();

4. 성별이 "여자"이고 포인트가 1700이상인 멤버를 검색합니다.
  db.member.find({$and:[{'gender':'여자'}, {'point':{$gte:1700}}]}).pretty();


document 정렬
db.컬렉션명.find().sort(객체);

db.member.find().sort();
db.member.find().sort({"_id":-1}).pretty();

*객체 
{key:value} -> key는 데이터의 field이름,value의 값은 1(오름차순) 또는 -1(내림차순)
여러 key를 입력할 수 있고, 먼저 입력한 key가 우선권을 갖음.

document의 개수 제한
limit():출력할 데이터 개수를 제한할때 사용
db.컬렉션명.find().limit(출력할 개수)
db.member.find().limit(3).pretty();

document 데이터 생략 후 출력
skip():출력할 데이터의 시작부분을 설정할 경우 사용
db.컬렉션명r.find().skip(생략할 개수);
db.member.find().skip(2).pretty();